= Test::Unit Given

Author::  Dave Copeland (mailto:davetron5000 at g mail dot com)
Copyright:: Copyright (c) 2011 by Dave Copeland
License:: Distributes under the Apache License, see LICENSE.txt in the source distro

Get your Test::Unit test cases readable and fluent, without RSpec, magic, or crazy meta-programming.

This library is a set of small, simple tools to make your Test::Unit test cases easy to understand.  This isn't a massive change in how you write tests, but simply some helpful things will make your tests easier to read.

The main problems this library solves are:

* Understanding what part of a test method is setup, test, and evaluation
* Understanding what elements of a test are relevant, and which are arbitrary
* Using strings to describe your tests without requiring active support

== Install

    gem install test_unit-given

Or, with bundler:

    gem "test_unit-given", :require => "test/unit/given"

== Overview

    class Circle
      attr_reader :name
      attr_reader :radius

      def initialize(radius,name)
        @radius = radius
        @name = name
      end

      def area
        @radius * @radius * 3.14
      end

      def to_s
        "circle of radius #{radius}, named #{name}"
      end

    end

    require 'test/unit/given'

    class CircleTest < Test::Unit::Given::TestCase
      test_that "area is computed correctly" {
        Given {
          @circle = Circle.new(10,any_string)
        }
        When {
          @area = @circle.area
        }
        Then {
          assert_equal 314,@area
        }
      }

      test_that "to_s includes the name" {
        Given { 
          @name = "foo"
          @circle = Circle.new(any_int,@name)
        }
        When {
          @string = @circle.to_s
        }
        Then {
          assert_match /#{@name}/,@string
        }
      }
    end

What's going on here?

* We can clearly see which parts of our test are setting things up (stuff inside +Given+), which parts are executing the code we're testing (stuff in +When+) and which parts are evalulating the results (stuff in +Then+)
* We can see which values are relevant to the test - only those that are literals.  In the first test, the +name+ of our circle is not relevant to the test, so instead of using a dummy value like +foo+, we use +any_string+, which makes it clear that the value _does not matter_.  Similarly, in the second test, the radius is irrelevant, so we use +any_int+ to signify that it doesn't matter.
* Our tests are clearly named and described with strings, but we didn't need to bring in active support.

But, don't fret, this is not an all-or-nothing proposition.  Use whichever parts you like.  Each feature is in a module that you can include as needed, or you can do what we're doing here and extend Test::Unit::Given::TestCase to get everything at once.

== More Info

* Test::Unit::Given::TestCase is the base class that gives you everything
* Test::Unit::Given::GivenWhenThen provides the Given/When/Then construct
* Test::Unit::Given::TestThat provides +test_that+
* Test::Unit::Given::Any provides the +any_string+ and friends.

== Questions you might have

=== Why?

I'm tired of unreadable tests.  Tests should be good, clean code, and it shoud be easy to see what's being tested.  This is especially important when there is a lot of setup required to simulate something.

I also don't believe we need to resort ot a lot of metaprogramming tricks just to get our tests in this shape.  RSpec, for example, creates strange constructs for things that are much more straightforward in plain Ruby.  I like Test::Unit, and with just a bit of helper methods, we can make nice, readable tests, using just Ruby.

=== But the test methods are longer!

And?  I don't mind a test method that's a bit longer if that makes it easy to understand.  Certainly, a method like this is short:


    def test_radius
      assert_equal 314,Circle.new(10).radius
    end

But, we rarely get such simple methods *and* this test method isn't very modifiable; everything is on one line and it doesn't encourage re-use.  We can do better.

=== What about mocks?

Mocks create an interesting issue, because the "assertions" are the mock expectations you setup before you call the method under test.  This means that the "then" side of things is out of order.

    class CircleTest < Test::Unit::Given::TestCase
      test_that "our external diameter service is being used" do
        Given {
          @diameter_service = mock()
          @diameter_service.expects(:get_diameter).with(10).returns(400)
          @circle = Circle.new(10,@diameter_service)
        }
        When  {
          @diameter = @circle.diameter
        }
        Then {
          // assume mocks were called
        }
      end
    end

This is somewhat confusing.  We could solve it using two blocks provided by this library, +the_test_runs+, and +mocks_shouldve_been_called+, like so:

    class CircleTest < Test::Unit::Given::TestCase
      test_that "our external diameter service is being used" do
        Given {
          @diameter_service = mock()
        }
        When the_test_runs
        Then {
          @diameter_service.expects(:get_diameter).with(10).returns(400)
        }
        Given {
          @circle = Circle.new(10,@diameter_service)
        }
        When  {
          @diameter = @circle.diameter
        }
        Then mocks_shouldve_been_called
      end
    end

Although both <tt>the_test_runs</tt> and <tt>mocks_shouldve_been_called</tt> are no-ops,
they allow our tests to be readable and make clear what the assertions are that we are making.

Yes, this makes our test a bit longer, but it's *much* more clear.

=== What about block-based assertions, like +assert_raises+

Again, things are a bit out of order, but if you invert Then and When, you'll still get a readable test:

    class CircleTest < Test::Unit::Given::TestCase

      test_that "there is no diameter method" do
        Given {
          @circle = Circle.new(10)
        }
        Then {
          assert_raises NoMethodError do
            When {
              @circle.diameter
            }
          end
        }
      end
    end

=== Why Any instead of Faker?

Faker is used by Any under the covers, but Faker has two problems:

* We aren't _faking_ values, we're using _arbitrary_ values.  There's a difference semantically, even if the mechanics are the same
* Faker requires too much typing to get arbitrary values.  I'd rather type +any_string+ than <tt>Faker::Lorem.words(1).join(' ')</tt>

=== What about Factory Girl?

Again, FactoryGirl goes through metaprogramming hoops to do something we can already do in Ruby: call methods.  The Any module is extensible, in that you can do stuff like <tt>any Person</tt>, but you can, and should, just use methods.  Any helps out with primitives that we tend to use a lot: numbers and strings.  It's just simpler and, with less moving parts, more predictable.  This means you spend more time on your tests than on your test infrastructure.

=== What about not using the base class?

To use Test::Unit::Given::Any on its own:

    require 'test/unit/given/any'

    class MyTest < Test::Unit::TestCase
      include Test::Unit::Given::Any
    end

To use Test::Unit::Given::GivenWhenThen on its own:

    require 'test/unit/given/given_when_then'

    class MyTest < Test::Unit::TestCase
      include Test::Unit::Given::GivenWhenThen
    end

To use Test::Unit::Given::TestThat on its own:

    require 'test/unit/given/test_that'

    class MyTest < Test::Unit::TestCase
      include Test::Unit::Given::TestThat
    end
